<!DOCTYPE html>
<html>

<head>
  <title>B R E A K I N G * β α ∆</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link rel="stylesheet" href="css/font-awesome.min.css" />
  <link rel="stylesheet" href="css/main.css" />
  <link rel="subresource" href="css/light.css" />
  <link rel="subresource" href="css/dark.css" />
</head>

<body>
  <!-- WALTER interface -->
  <div id="small-viewers">
    <div id="viewer1" class="mini-viewer"></div>
    <div id="viewer2" class="mini-viewer"></div>
    <div id="viewer3" class="mini-viewer"></div>
    <div id="viewer4" class="mini-viewer"></div>
  </div>
  <div id="chat-container"></div>
  <div id="transcription"></div>

  <!-- NGL -->
  <script src="../dist/ngl.js"></script>

  <!-- NGL UI components -->
  <script src="js/lib/signals.min.js"></script>
  <script src="js/lib/tether.min.js"></script>
  <script src="js/lib/colorpicker.min.js"></script>
  <script src="js/ui/ui.js"></script>
  <script src="js/ui/ui.extra.js"></script>
  <script src="js/ui/ui.ngl.js"></script>
  <script src="js/gui.js"></script>

  <!-- NGL Viewer setup -->
  <script>
      NGL.cssDirectory = "css/";
      NGL.documentationUrl = "../build/docs/";
      NGL.examplesListUrl = "../build/scriptsList.json";
      NGL.examplesScriptUrl = "./scripts/";

      // Datasources
      NGL.DatasourceRegistry.add("data", new NGL.StaticDatasource("../data/"));
      var mdsrv = NGL.getQuery("mdsrv");
      if (mdsrv) {
        var mdsrvDatasource = new NGL.MdsrvDatasource(mdsrv);
        NGL.DatasourceRegistry.add("file", mdsrvDatasource);
        NGL.setListingDatasource(mdsrvDatasource);
        NGL.setTrajectoryDatasource(mdsrvDatasource);
      }

      document.addEventListener("DOMContentLoaded", function () {
          var stage = new NGL.Stage('viewer-container');
          NGL.StageWidget(stage);

          window.miniStages = [];
          var miniViewerIds = ['viewer1', 'viewer2', 'viewer3', 'viewer4'];
          miniViewerIds.forEach(function(id) {
              var ministage = new NGL.Stage(id);
              window.miniStages.push(ministage);
              
          miniViewerIds.forEach(function(id) {
              var elem = document.getElementById(id);
              console.log(id, 'Offset:', elem.offsetWidth, elem.offsetHeight);
          });
          });

          function onFileLoaded(file) {
              console.log('File loaded:', file);
              if (window.reactAppHandleFileLoad) {
                  window.reactAppHandleFileLoad(file);
              }
          }

          // Override the default loadFile method to include the callback
          const originalLoadFile = stage.loadFile.bind(stage);
          stage.loadFile = function (file, params) {
              return originalLoadFile(file, params).then(component => {
                  onFileLoaded(file);  
                  return component;
              });
          };

          var load = NGL.getQuery("load");
          if (load) stage.loadFile(load, {defaultRepresentation: true});

          var script = NGL.getQuery("script");
          if (script) stage.loadScript("./scripts/" + script + ".js");

          var struc = NGL.getQuery("struc");
          var traj = NGL.getQuery("traj");
          if (struc) {
              stage.loadFile(struc, {
                  defaultRepresentation: true
              }).then(function(o) {
                  if (traj) o.addTrajectory(traj);
              });
          }

          window.currentViewerIndex = 0;
          window.determineViewerIndex = function() {
              const index = window.currentViewerIndex;
              window.currentViewerIndex = (window.currentViewerIndex + 1) % window.miniStages.length; 
              return index;
          };

          window.loadFileIntoMiniViewer = function(file, index) {
              console.log("Index:", index, "Length of miniStages:", miniStages.length);
              if (index < miniStages.length) {
                  miniStages[index].loadFile(file, {defaultRepresentation: true});
              } else {
                  console.error('Invalid viewer index');
              }
          };
          window.addEventListener('load', () => {
              miniViewerIds.forEach(function(id) {
                  var elem = document.getElementById(id);
                  elem.style.display = 'block'; // Force reflow/repaint
              });
          });
      });
  </script>

  <!-- REACT -->
  <script type="text/babel">
    const ChatComponent = () => {
        const [query, setQuery] = React.useState('');
        const [result, setResult] = React.useState('');
        const [currentFile, setCurrentFile] = React.useState(null);  

        window.reactAppHandleFileLoad = (file) => {
            console.log('React handling file load:', file);
            setCurrentFile(file);
        };

        React.useEffect(() => {
            return () => {
                window.reactAppHandleFileLoad = null;  // Clean up 
            };
        }, []);

        /// WHISPER DROGON SERVER
        const socket = new WebSocket('ws://localhost:9001/transcribe');
  
        socket.addEventListener('open', () => {
          console.log('WebSocket connection established');
          // socket.send('Hi');
        });
      
        socket.addEventListener('message', (event) => {
          const transcribedText = event.data;
          document.getElementById('transcription').textContent = transcribedText;
          handleSubmit(transcribedText);
        });
      
        socket.addEventListener('close', () => {
          console.log('WebSocket connection closed');
        });

        function handleFileLoad(file) {
            const fileType = 'sdf'; 
            if (window.miniStages && window.miniStages.length > 0) {
                const viewerIndex = window.determineViewerIndex();
                console.log(`Loading file into viewer index ${viewerIndex}`);
                if (window.loadFileIntoMiniViewer) {
                    window.loadFileIntoMiniViewer(file, viewerIndex);
                } else {
                    console.error('loadFileIntoMiniViewer function is not defined');
                }
            } else {
                console.error('No viewer available or miniStages not defined.');
            }
        }

        const updateChatMessages = (newMessage, isUser = false) => {
            setResult((prevResult) => {
                const timestamp = new Date().toLocaleTimeString();
                const sender = isUser ? 'USER:' : 'WALTER:';
                const message = `${timestamp} ${sender}: ${newMessage}`;
                return `${prevResult}\n${message}`;
            });
         };

        const handleSubmit = async (e) => {
            e.preventDefault();
            console.log("Sending query:", query);
            updateChatMessages(query, true);
            
            const formData = new FormData();
            formData.append('prompt', query);
            formData.append('max_tokens', 256);
            formData.append('temperature', 1.0);
            formData.append('file', currentFile);

            try {
                const response = await fetch('http://51.159.183.152:8000/predict', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
              
                const textResponse = await response.text();
                console.log('Received response:', textResponse);

                const file = new File([textResponse], "loadedFile.sdf", {type: 'chemical/x-mdl-sdfile'});
                const reader = new FileReader();
                reader.onload = function(event) {
                    const fileContent = event.target.result;
                    updateChatMessages(fileContent); 
                    console.log('Content of the .sdf file:', fileContent);
                };
                reader.onerror = function(event) {
                    console.error('Error reading file:', event.target.error);
                };
                reader.readAsText(file);

                handleFileLoad(file);

            } catch (error) {
                console.error('Error:', error);
            }
        };

        return (
            <div className="chat-container">
            <div className="chat-result">
                {result.split('\n').map((message, index) => {
                    const [timestamp, sender, content] = message.split(': ');
                    return (
                        <div key={index} className={sender === 'USER' ? 'user-message' : 'agent-message'}>
                            <strong>{timestamp} {sender}</strong> {content}
                        </div>
                    );
                })}
            </div>
            <div className="chat-input">
                <form onSubmit={handleSubmit}>
                <input
                    type="text"
                    value={query}
                    onChange={(e) => setQuery(e.target.value)}
                    placeholder="START"
                />
                <button type="submit">SUBMIT</button>
                </form>
            </div>
            </div>
        );
    };

    ReactDOM.render(<ChatComponent />, document.getElementById('chat-container'));
  </script>

</body>
</html>
